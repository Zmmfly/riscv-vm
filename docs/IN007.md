# # RISC-V F 扩展，浮点指令实现

**R4指令类型**
基于R指令类型进行了部分修改，结构如下：

| 比特范围| 31 ~ 27 | 26 ~ 25 | 24 ~ 20 | 19 ~ 15 | 14 ~ 12 | 11 ~ 7 | 6 ~ 0  |
| :-:| :-:| :-:| :-:| :-:| :-:| :-:| :-:|
|   释义  |   src3  |   fmt   |   src2  |   src1  |   rm    |    dst | opcode |
|   位宽  |    5    |    2    |    5    |    5    |    3    |    5   |   7    |

## 指令清单
| 指令 | 类型 | OPCODE | func3 | func7 | 备注 |
| :-:  | :-: |   :-:  | :-: | :-: | :-: |
| flw  |  I  | 00'001'11| NONE | NONE | NONE |
| fsw  |  S  | 01'001'11 | NONE | NONE | NONE |
| fmadd.s | R4 | 10'000'11 | NONE | NONE | NONE |
| fmsub.s | R4 | 10'001'11 | NONE | NONE | NONE |
| fnmsub.s | R4 | 10'010'11 | NONE | NONE | NONE |
| fnmadd.s | R4 | 10'011'11 | NONE | NONE | NONE |
| fadd.s | R | 10'100'11 | NONE | 000'0000 | NONE |
| fsub.s | R | 10'100'11 | NONE | 000'0100 | NONE |
| fmul.s | R | 10'100'11 | NONE | 000'1000 | NONE |
| fdiv.s | R | 10'100'11 | NONE | 000'1100 | NONE |
| fsqrt.s| R | 10'100'11 | NONE | 010'1100 `(1)` | NONE |
| fsgnj.s| R | 10'100'11 | 000 | 001'0000 | NONE |
| fsgnjn.s | R | 10'100'11 | 001 | 001'0000 | NONE |
| fsgnjx.s | R | 10'100'11 | 010 | 001'0000 | NONE |
| fmin.s | R | 10'100'11 | 000 | 001'0100 | NONE |
| fmax.s | R | 10'100'11 | 001 | 001'0100 | NONE
| fcvt.w.s | R | 10'100'11 | NONE | 110'0000 | rs2 = 00000 |
| fcvt.wu.s | R | 10'100'11 | NONE | 110'0000 | rs2 = 00001 |
| fmv.x.w | R | 10'100'11 | 000 | 111'0000 | rs2 = 00000 |
| feq.s | R | 10'100'11 | 010 | 101'0000 | NONE |
| flt.s | R | 10'100'11 | 001 | 101'0000 | NONE |
| fle.s | R | 10'100'11 | 000 | 101'0000 | NONE |
| fclass.s | R | 10'100'11 | 001 | 111'0000 | NONE |
| fcvt.s.w | R | 10'100'11 | NONE | 110'1000 | rs2 = 00000 |
| fcvt.s.wu | R | 10'100'11 | NONE | 110'1000 | rs2 = 00001 |
| fmv.w.x | R | 10'100'11 | 000 | 111'1000 | rs2 = 00000 |

**附注**
- `(1)`: `参考1` 指令清单中，`fsqrt.s` 与 `fsqrt.s` 标注一致，查阅 `参考2` 应为 `010'1100`

## 指令行为：
1. `flw`
   - `f32[rd] = M[ x[rs1] + sext(imm) ] [31:0]`
2. `fsw`
   - `M[ x[rs1] + sext(imm) ] = f32[rs2] [31:0]`
3. `fmadd.s`
   - `f32[rd] = f32[rs1] x f32[rs2] + f32[rs3]`
4. `fmsub.s`
   - `f32[rd] = f32[rs1] x f32[rs2] - f32[rs3]`
5. `fnmsub.s`
   - `f32[rd] = -(f32[rs1] x f32[rs2]) + f32[rs3]`
6. `fnmadd.s`
   - `f32[rd] = -(f32[rs1] x f32[rs2]) - f32[rs3]`
7. fadd.s
   - `f32[rd] = f32[rs1] + f32[rs2]`
8. fsub.s
   - `f32[rd] = f32[rs1] - f32[rs2]`
9.  fmul.s
   - `f32[rd] = f32[rs1] x f32[rs2]`
10. fdiv.s
   - `f32[rd] = f32[rs1] / f32[rs2]`
11. fsqrt.s
   - `f32[rd] = sqrt(f32[rs1])`
12. fsgnj.s
   - `f32[rd] = { f32[rs2][31], f32[rs1][31:0] }`
13. fsgnjn.s
   - `f32[rd] = { ~f32[rs2][31], f32[rs1][31:0] }`
14. fsgnjx.s
   - `f32[rd] = { f32[rs1][31] ^ f32[rs2][31], f32[rs1][31:0] }`
15. fmin.s
   - `f32[rd] = min(f32[rs1], f32[rs2])`
16. fmax.s
   - `f32[rd] = max(f32[rs1], f32[rs2])`
17. fcvt.w.s
   - `x[rd] = sext( (signed 32) f32[rs1] )`
18. fcvt.wu.s
   - `x[rd] = sext( (unsigned 32) f32[rs1] )`
19. fmv.x.w
   - `x[rd] = sext( f32[rs1][31:0] )`
20. feq.s
   - `x[rd] = f32[rs1] == f[rs2] ? 1 : 0`
21. flt.s
   - `x[rd] = f32[rs1] < f[rs2] ? 1 : 0`
22. fle.s
   - `x[rd] = f32[rs1] <= f[rs2] ? 1 : 0`
23. fclass.s
   - `x[rd] = classify(f32[rs1])`, 对`f32[rs1]`进行分类，`x[rd]`有且仅有一位被置位，比特位置位时的含义如下：
     - 0 `f32[rs1]` 为 负无穷
     - 1 `f32[rs1]` 为 负规格数(negative normal number)
     - 2 `f32[rs1]` 为 负次规格数(negative subnormal nnumber)
     - 3 `f32[rs1]` 为 -0
     - 4 `f32[rs1]` 为 +0
     - 5 `f32[rs1]` 为 正次规格数(positive subnormal number)
     - 6 `f32[rs1]` 为 正规格数(postive normal number)
     - 7 `f32[rs1]` 为 正无穷
     - 8 `f32[rs1]` 为 信号(signaling) NaN
     - 9 `f32[rs1]` 为 静默(quit) NaN
24. fcvt.s.w
   - `f[rd] = (f32) ((s32) x[rs1])`
25. fcvt.s.wu
   - `f[rd] = (f32) ((u32) x[rs1])`
26. fmv.w.x
   - `f32[rd] = x[rs1][31:0]`

## IEEE754
修订版本: 2008

### 数据结构

|  type   |     Sign    |   Exponent  | 阶码范围.规格化  | bias = 2^(e-1) - 1  |  Faction(Mantissa)   |
|:-------:|:-----------:|:-----------:|:---------------:|:-------------------:|:--------------------:|
| fp16    | 1b`[15:15]` | 5b`[14:10]` | -14 ~ 15        | 2^(5-1) - 1 = 15    |       10b`[9:0]`     |
| float   | 1b`[31:31]` | 8b`[30:23]` | -126 ~ 127      | 2^(8-1) - 1 = 127   |      23b`[22:0]`     |
| double  | 1b`[63:63]` | 11b`[62:52]`| -1022 ~ 1023    | 2^(11-1) - 1 = 1023 |      52b`[51:0]`     |

`exponent` = `biased_exponent` + `bias`
`biased_exponent` = 阶码真值, 例： `1.010101 x 10 ^ 4`中的`4`

### 编码还原
1. 借用[trekhleb](https://github.com/trekhleb)的图, 半精度, 规格化:
![fp16calculate](./images/half-precision-floating-point-number-explained.png)
2. 非规格化参考: 参考6

### 小数编码
E = 指数
M = 尾数
S = 符号

**21.25**

以下以转换为单精度为例：

1. 整数部分变换为二进制: `10101`
2. 小数部分`0.25`变换为二进制：
   - 0.25 x 2 = 0.5, pick 0
   - 0.5 x 2 = 1, pick 1
3. 合并二进制, `10101`.`01`
4. 小数点移位表示, 左移4位, 即 `1.010101 x 10 ^ (exp = 4)`
5. 取小数部分作为尾数 M = 010101
6. 指数 E = exp + bias = 4 + 127 = 131 = 0b1000'0011
7. 组合起来, `0 1000 0011 010101 00000000000000000`, 16进制：41AA0000

**50.25**
float: 42490000

**5.125**
float: 40a40000

**-11.125**
float: c1320000

**-6.125**
float: c0c40000

### 四则运算

#### 舍入模式
四则运算不可避免的需要舍入模式来控制最终的结果, IEEE75中有以下4种舍入模式

1. 最近偶数舍入 `Round to Nearest, Tie to Even`: 这是默认的舍入模式。在这种模式下，如果一个数正好位于两个可表示值的中间，那么它会被舍入到最近的偶数可表示值。这种方法有助于减少舍入误差在计算中的累积
2. 向零舍入 `Round Toward Zero`: 在这种模式下，数值总是被舍入到最接近的零方向的可表示值。这与传统的截断方法相同。
3. 向正无穷大舍入 `Round Toward Positive Infinity`: 在这种模式下，数值被舍入到最接近的但不小于原数的可表示值。
4. 向负无穷大舍入 `Round Toward Negative Infinity`: 在这种模式下，数值被舍入到最接近的但不大于原数的可表示值。

##### 示例（GPT）：
问：
请给出以下几个二进制小数的舍入示例，保留小数点后3位二进制，分别展示四种舍入方法的过程和结果：1.0011001、1.0010111、-1.0011000、-1.0101000、1.0010000、-1.0011010

答：

1. 1.0011001

    最近偶数舍入（Round to Nearest, Tie to Even）：

        舍入到1.010，因为第四位是1（表示大于中间值），所以向上舍入。

    向零舍入（Round Toward Zero）：

        舍入到1.001，因为向零舍入意味着舍弃所有超过三位的部分。

    向正无穷大舍入（Round Toward Positive Infinity）：

        舍入到1.010，因为向上舍入到最接近的更大数。

    向负无穷大舍入（Round Toward Negative Infinity）：

        舍入到1.001，即使它是正数，向负无穷大舍入也意味着向下舍入。

2. 1.0010111

    最近偶数舍入（Round to Nearest, Tie to Even）：

        舍入到1.001，因为即使第四位是1，但舍入到最近的偶数表示值意味着保持不变。

    向零舍入（Round Toward Zero）：

        同上，舍入到1.001。

    向正无穷大舍入（Round Toward Positive Infinity）：

        舍入到1.010，向上舍入到最接近的更大数。

    向负无穷大舍入（Round Toward Negative Infinity）：

        舍入到1.001，向下舍入。

3. -1.0011000

    最近偶数舍入（Round to Nearest, Tie to Even）：

        舍入到-1.010，因为第四位是0且我们在负数区域，但因为没有中间值的紧张，所以保持不变。

    向零舍入（Round Toward Zero）：

        舍入到-1.001。

    向正无穷大舍入（Round Toward Positive Infinity）：

        舍入到-1.001，因为向正无穷方向意味着在负数区域向上舍入。

    向负无穷大舍入（Round Toward Negative Infinity）：

        舍入到-1.010，向下舍入到更负的数。

4. -1.0101000

    最近偶数舍入（Round to Nearest, Tie to Even）：

        舍入到-1.011，因为第四位是1，表示需要向上舍入。

    向零舍入（Round Toward Zero）：

        舍入到-1.010。

    向正无穷大舍入（Round Toward Positive Infinity）：

        舍入到-1.010。

    向负无穷大舍入（Round Toward Negative Infinity）：

        舍入到-1.011。

5. 1.0010000

    对于这个数字，由于它已经是小数点后三位，所有舍入方法的结果都是1.001。

6. -1.0011010

    最近偶数舍入（Round to Nearest, Tie to Even）：

        舍入到-1.010，因为第四位是1，表示需要向上舍入。

    向零舍入（Round Toward Zero）：

        舍入到-1.001。

    向正无穷大舍入（Round Toward Positive Infinity）：

        舍入到-1.001。

    向负无穷大舍入（Round Toward Negative Infinity）：

        舍入到-1.010。

请注意，舍入时我们考虑的是如何最接近地表示原始数值，同时根据选定的舍入策略来优化精度。每种舍入方法都有其适用场景，选择哪一种取决于你希望如何处理数值的精度和舍入误差。

#### 加减法
1. 选取指数较小的数，将其尾数右移，右移的步数等于两指数之差
2. 将结果的指数设为与较大的指数相等
3. 对尾数进行加/减运算，并确定结果的符号
4. 如果必要，对结果的值进行规格化

##### 正数 + 正数
```
a + b = c
a = 50.25 = 1.1001001 x 10^5
b = 5.125 = 1.01001 x 10^2

aE = 10000100 = 127 + 5 = 132
aM = 10010010000000000000000

bE = 10000001 = 127 + 2 = 129
bM = 01001000000000000000000

bE < aE, 所以 bM >> (132 - 129) 
= 01001000000000000000000 >> 3 并补前置1
=   101001000000000000000
右移注意将前置省略的1补齐，不然计算错误

cE = max(aE, bE) 
= aE 
= 0b10000100 
= 127 + 5 = 132
```

|        |       二进制值         |
|:------:|----------------------:|
|aM      |10010010000000000000000|
|bM      |  101001000000000000000|
|cM=aM+bM|10111011000000000000000|

合并cS, cE, cM
c = 01000010010111011000000000000000

##### 正数 + 负数
a + b = c
a = 50.25
b = -6.125

aS = 0, bS = 1

|         |             binary             |
|:-------:|-------------------------------:|
|a        |01000010010010010000000000000000|
|b        |11000000110001000000000000000000|
|aE       |                        10000100|
|bE       |                        10000001|
|aM       |         10010010000000000000000|
|bM       |         10001000000000000000000|
|bM(shift)|           110001000000000000000|
|cM       |         01100001000000000000000|

```
aE = 10000100 = 132
bE = 10000001 = 129
cE = max(aE, bE) = 132

因为 bE < aE, 所以 bM 右移 132 - 129 = 3 位, 即 110001000000000000000
因为 bM(shift) < aM 且 bS置位, 所以 cM = aM - bM(shift) = 01100001000000000000000
合并 cS, cE, cM = 0 10000100 01100001000000000000000
```

##### 负数 + 正数
流程与正数+负数类似，注意最终符号即可

##### 减法
假设 a - b, 将 b符号取反做加法运算即可

#### 乘法
1. 将指数相加并减去127以保持余127表示
2. 将尾数相乘并以尾数宽度作为移位长度右移
3. 检查尾数移位后的结果是否溢出包含隐藏1的尾数表达范围（即24位），溢出则指数+1，并将尾数再次右移1位
4. 如果必要，对结果的值进行规格化（将尾数置于可表达范围内、隐去前置1）

```
a x b = c
a = 50.25 = 1.1001001 x 10^5
b = 5.125 = 1.01001 x 10^2

cE 
    = aE + bE - bias 
    = 10000100 + 10000001 - 127 
    = 134 
    = 10000110

cM  = aM x bM >> 23
    = 110010010000000000000000 x 101001000000000000000000 >> 23
    = 100000001100010000000000000000000000000000000000 >> 23
    = 1000000011000100000000000

1000000011000100000000000 > 0xffffff, 所以继续右移1位, 同时指数+1

即：
最终cE = cE + 1 = 134 + 1 = 10000111
最终的cM为 100000001100010000000000，去除前置1为 00000001100010000000000

组合cS, cE, cM，即

0 10000111 00000001100010000000000
```

转换回小数，即
**257.53125**

|         |             binary             |
|:-------:|-------------------------------:|
|a        |01000010010010010000000000000000|
|b        |01000000101001000000000000000000|
|aE       |                        10000100|
|bE       |                        10000001|
|aM       |         10010010000000000000000|
|bM       |         01001000000000000000000|
|cE       |                        10000111|
|cM       |         00000001100010000000000|

#### 除法
1. 将指数相减并加上127以保持余127表示
2. 将尾数相除并确定结果的符号
3. 如果必要，对结果的值进行规格化

```
a / b = c
a = 50.25 = 1.1001001 x 10^5
b = 5.125 = 1.01001 x 10^2

cE  = aE - bE + bias 
    = 10000100 - 10000001 + 127 
    = 130 
    = 10000010

aM2 = aM 补齐隐含1, 如果aM > bM, 左移31位, 否则cE - 1, 并左移32位
bM2 = bM 补齐隐含1
cM = 规格化(aM2 / bM2)
```

下面的规格化直接截断进行右移8位，保留24位
```
cM  = 规格化(aM2 / bM2)
    = 规格化(1100100100000000000000000000000000000000000000000000000 / 101001000000000000000000)
    = 规格化(10011100111000001100011111001110)
    = 100111001110000011000111
```
组合 cS cE cM
```
0 10000010 00111001110000011000111
   = 9.80487728118896484375
```
和 win10 自带计算器对比
```
manual: 0 10000010 00111001110000011000111 = 9.80487728118896484375
win10 : 0 10000010 00111001110000011001000 = 9.8048780487804878048780487804878
```
可以看出明显的舍入区别，在截断时计算器进行了进位舍入

|         |             binary             |
|:-------:|-------------------------------:|
|a        |01000010010010010000000000000000|
|b        |01000000101001000000000000000000|
|aE       |                        10000100|
|bE       |                        10000001|
|aM       |         10010010000000000000000|
|bM       |         01001000000000000000000|
|cE       |                        01111100|
|cM       |         00111001110000011000111|

0 01111100 00111001110000011000111

## 参考
1. 指令清单: [RISC-V-Reader-Chinese-v2p1.pdf](./pdf/RISC-V-Reader-Chinese-v2p1.pdf) PDF第59页，电子书57页
2. R4指令类型: [Volume1_riscv-spec-20191213.pdf](./pdf/Volume1_riscv-spec-20191213.pdf) PDF第69页
3. `https://www.binaryconvert.com/convert_double.html`
4. `https://www.h-schmidt.net/FloatConverter/IEEE754.html`
5. `https://www.toolhelper.cn/Digit/FractionConvert`
6. `https://upimg.baike.so.com/doc/643382-681042.html`
7. 浮点数运算法则1：`https://blog.csdn.net/qq_34026204/article/details/122071917`
8. 浮点数运算法则2：`https://www.cnblogs.com/PeaZomboss/p/17803921.html`, 可直接看代码
9. 浮点数在线转换1：`https://numeral-systems.com/ieee-754-converter/`, 步骤详细
10. 浮点数在线换换2：`https://www.h-schmidt.net/FloatConverter/IEEE754.html`, 16进制，二进制均可查看
11. 浮点数加法：`https://numeral-systems.com/ieee-754-add/`, 步骤详细7
12. 舍入模式：`https://blog.csdn.net/weixin_42454243/article/details/121922333`
13. 浮点数运算：`https://www.rfwireless-world.com/Tutorials/floating-point-tutorial.html`
