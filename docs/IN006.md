# RISC-V A 扩展，原子指令实现笔记

粗略可理解为不可再细分的内存操作，在硬件层面，可参考`参考1`中的两段话进行理解：

*RISC-V 架构的原子拓展（Atomic，简称 A 拓展）提供了一些对于一个内存位置上的值进行原子操作的原子指令，分为两大类。其中第一类被称为原子内存操作（Atomic Memory Operation, AMO）。这类原子指令首先根据寄存器 rs1 保存的内存地址将值从内存载入到寄存器 rd 中，然后将这个载入的值与寄存器 rs2 中保存的值进行某种运算，并将结果写回到 rs1 中的地址对应的内存区域中。整个过程可以被概括为一种 read-modify-write 的三阶段操作，硬件能够保证其原子性。AMO 支持多种不同的运算，包括交换、整数加法、按位与、按位或、按位异或以及有/无符号整数最大或最小值。容易看出，这类指令能够方便地实现 adder_fixed.rs 中 Rust 提供的 fetch_add 这类原子操作。*

*RISC-V 提供的另一类原子指令被称为加载保留/条件存储（Load Reserved / Store Conditional，简称LR/SC），它们通常被配对使用。首先， LR 指令可以读取内存中的一个值（其地址保存在寄存器 rs1 中）到目标寄存器 rd 。然后，可以使用 SC 指令，它的功能是将内存中的这个值（其地址保存在寄存器 rs1 中且与 LR 指令中的相同）改成寄存器 rs2 保存的值，但前提是：执行 LR 和 SC 这两条指令之间的这段时间内，内存中的这个值并未被修改。如果这个前提条件不满足，那么 SC 指令不会进行修改。SC 指令的目标寄存器 rd 指出 SC 指令是否进行了修改：如果进行了修改， rd 为 0；否则， rd 可能为一个非零的任意值。*

*那么 SC 指令是如何判断此前一段时间该内存中的值是否被修改呢？在 RISC-V 架构下，存在一个 保留集 (Reservation Set) 的概念，这也是“加载保留”这种叫法的来源。保留集用来实现 LR/SC 的检查机制：当 CPU 执行 LR 指令的时候，硬件会记录下此时内存中的值是多少，此外还可能有一些附加信息，这些被记录下来的信息就被称为保留集。之后，当其他 CPU 或者外设对内存这个值进行修改的时候，硬件可以将这个值对应的保留集标记为非法或者删除。等到之前执行 LR 指令的 CPU 执行 SC 指令的时候，CPU 就可以检查保留集是否存在/合法或者保留集记录的值是否与内存中现在的值一致，以这种方式来决定是否进行写入以及目标寄存器 rd 的值。*

根据以上描述，在硬件层面，需要`记录`LR指令操作的`内存值`，在`其它CPU`对这个对应地址的值进行`修改`时，需要`对记录`的值`进行标记`，
可标记为`非法`或者`删除`；**RISC-V规范中并没有规范实现方式**

## 逻辑
1. 虚拟总线上
   1. 对于LR操作，需要在获取锁后，进行记录并操作，然后释放锁
   2. 对于SC操作，需要在索取锁后，检查记录并操作，然后释放锁
   3. 对于任意CPU，写操作时，需要在获取锁后，检查操作地址和内容是否与记录相干，相干则标记，然后释放锁

## 指令
### `lr.w`

语法：`lr.w rd, rs1`

动作: 
   1. `x[rd] = sext(M[x[rs1]])`, rs1指向的寄存器内容作为内存地址，加载4个字节，符号位扩展后写入`x[rd]`
   2. `LoadReserved32(M[x[rs1]])`, 并对这个内存字注册保留

伪代码：
```
// lr.w指令加载内存中的数据到寄存器rd，并保留该内存位置的状态
function lr_w(rd, rs1):
    addr = rs1  // 从rs1寄存器中获取要加载数据的内存地址
    data = 读取内存(addr)  // 从内存中读取地址为addr的数据
    rd = data  // 将数据写入寄存器rd
    标记内存位置addr的状态为保留
    返回 rd
```

### `sc.w`

语法：`sc.w rd, rs2, (rs1)`

动作：
   1. `x[rd] = StoreConditional32(M[x[rs1], x[rs2]])`
      1. 检查rs1指向的寄存器内容所表示的地址是否处于保留集中，并且是否未被修改
      2. 如果条件符合，将rs2指向的寄存器内容写入rs1指向内存地址上，并将rd指向的寄存器置0
      3. 否则rd指向的寄存器内容置非0

伪代码：
```
// sc.w指令尝试将寄存器rs2中的数据写回到内存中的地址rs1，并根据之前执行的lr.w操作的状态决定操作是否成功
function sc_w(rs1, rs2):
    if (rs1 在保留集中 && 保留集[rs1] 未被修改):
        写入内存(rs1, rs2)  // 尝试将寄存器rs2中的数据写回到内存中的地址rs1
        返回 成功  // 操作成功
    else:
        返回 失败  // 操作失败
```

### `amoswap.w`

语法：`amoswap.w rd, rs2, (rs1)`

动作：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = x[rs2]`

### `amoadd.w`

语法：`amoadd.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = M[x[rs1]] + x[rs2]`

### `amoxor.w`

语法：`amoxor.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = M[x[rs1]] ^ x[rs2]`

### `amoand.w`

语法：`amoand.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = M[x[rs1]] & x[rs2]`

### `amoor.w`

语法：`amoor.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = M[x[rs1]] | x[rs2]`

### `amomin.w`

语法：`amomin.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = min( (s32) M[x[rs1]], sext( (s32) x[rs2]) ) `

### `amomax.w`

语法：`amomax.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = max( (s32) M[x[rs1]], sext( (s32) x[rs2]) ) `

### `amominu.w`

语法：`amominu.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = min( (u32) M[x[rs1]],  (u32) x[rs2] ) `

### `amomaxu.w`

语法：`amomaxu.w rd, rs2, (rs1)`

行为：
    1. `x[rd] = sext(M[x[rs1]])`
    2. `M[x[rs1]] = max( (u32) M[x[rs1]],  (u32) x[rs2] ) `

# 参考
1. [rCore-Tutorial-Book 第三版，第八章·并发·RISC-V 架构上的原子指令](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter8/2lock.html#risc-v)
